# Office Document Text Extraction Enhancement Plan

## Version 1.0 | January 2026

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Current Architecture](#2-current-architecture)
3. [Proposed Enhancements](#3-proposed-enhancements)
4. [Complete Pipeline Flow](#4-complete-pipeline-flow)
5. [Implementation Details](#5-implementation-details)
6. [Dependencies & Configuration](#6-dependencies--configuration)
7. [Testing Strategy](#7-testing-strategy)
8. [Migration & Rollout Plan](#8-migration--rollout-plan)
9. [Performance Benchmarks](#9-performance-benchmarks)
10. [Risk Mitigation](#10-risk-mitigation)

---

## 1. Executive Summary

### Goal
Enhance SortAI's ability to extract text from Microsoft Office documents by adding:
1. **Spotlight Metadata Extraction** - Leverage macOS's indexed text content
2. **CoreXLSX Integration** - Native Swift Excel parsing
3. **Enhanced PowerPoint Extraction** - Improve .pptx text extraction
4. **Multi-Method Aggregation** - Try all methods, combine results

### Key Principles
- **Spotlight First** - Fastest method when available, skip silently if not indexed
- **Graceful Degradation** - Never throw errors for extraction failures; fallback to next method
- **Maximum Text Capture** - Try ALL methods and aggregate results
- **Manual Review Flag** - Files with insufficient text are flagged for human review
- **Configurable** - Fast mode (skip slow methods) vs Thorough mode (trigger indexing)

### Success Criteria
- 95%+ of modern Office documents (.docx, .xlsx, .pptx) successfully extract text
- 80%+ of legacy documents (.doc, .xls, .ppt) extract at least filename metadata
- No extraction failures stop the pipeline
- Processing time per Office document < 3 seconds average

---

## 2. Current Architecture

### 2.1 Pipeline Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           SORTAI PROCESSING PIPELINE                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                 â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚  File   â”‚â”€â”€â”€â–¶â”‚ FileRouter  â”‚â”€â”€â”€â–¶â”‚MediaInspectorâ”‚â”€â”€â”€â–¶â”‚  FileSignature  â”‚   â”‚
â”‚   â”‚  Input  â”‚    â”‚  (UTType)   â”‚    â”‚   (Eye)      â”‚    â”‚  (Normalized)   â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                   â”‚            â”‚
â”‚                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                   â–¼                                                            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚ EmbeddingGeneratorâ”‚â”€â”€â”€â–¶â”‚   MemoryStore    â”‚â”€â”€â”€â–¶â”‚  UnifiedCategorizer â”‚   â”‚
â”‚   â”‚ (NL Embedding)   â”‚    â”‚ (Pattern Match)  â”‚    â”‚  (LLM Cascade)      â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                 â”‚              â”‚
â”‚                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                   â–¼                                                            â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚   â”‚ ProcessingResult â”‚â”€â”€â”€â–¶â”‚  FeedbackManager  â”‚â”€â”€â”€â–¶â”‚  SafeFileOrganizer  â”‚   â”‚
â”‚   â”‚ (Category+Path)  â”‚    â”‚ (Accept/Review)   â”‚    â”‚  (Move/Copy/Link)   â”‚   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 Current Office Extraction Methods

| Format | Current Methods | Reliability |
|--------|----------------|-------------|
| .docx | ZIPâ†’XML, NSAttributedString (OOXML/DOC), textutil, filename | Medium-High |
| .doc | NSAttributedString (DOC), textutil, filename | Low-Medium |
| .xlsx | ZIPâ†’sharedStrings.xml (basic) | Medium |
| .xls | File metadata only | Very Low |
| .pptx | ZIPâ†’slide XML (basic) | Medium |
| .ppt | File metadata only | Very Low |

### 2.3 Current Code Location

```
Sources/SortAI/Core/Eye/MediaInspector.swift
â”œâ”€â”€ inspectDocument()           # Main document inspection entry point
â”œâ”€â”€ extractWordDocument()       # Word extraction (5 strategies)
â”œâ”€â”€ extractExcelDocument()      # Excel extraction (ZIP-based)
â”œâ”€â”€ extractPowerPointDocument() # PowerPoint extraction (ZIP-based)
â”œâ”€â”€ extractDocxFromZip()        # DOCX ZIP parsing
â”œâ”€â”€ extractXLSXContent()        # XLSX ZIP parsing
â””â”€â”€ extractViaTextutil()        # textutil CLI fallback
```

---

## 3. Proposed Enhancements

### 3.1 New Extraction Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        ENHANCED OFFICE EXTRACTION FLOW                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                 â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚   â”‚                    OfficeDocumentExtractor (NEW)                        â”‚  â”‚
â”‚   â”‚                                                                         â”‚  â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚   â”‚  â”‚ Strategy 1: Spotlight Metadata (FIRST - fastest if available)   â”‚   â”‚  â”‚
â”‚   â”‚  â”‚ â”œâ”€â”€ MDItemCreate() â†’ MDItemCopyAttribute(kMDItemTextContent)   â”‚   â”‚  â”‚
â”‚   â”‚  â”‚ â””â”€â”€ Skip silently if not indexed                                â”‚   â”‚  â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚   â”‚                               â”‚ â–¼ (continue to try all)                â”‚  â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚   â”‚  â”‚ Strategy 2: Native Swift Parsers (per format)                   â”‚   â”‚  â”‚
â”‚   â”‚  â”‚ â”œâ”€â”€ .docx: ZIP + XMLParser (existing, enhanced)                 â”‚   â”‚  â”‚
â”‚   â”‚  â”‚ â”œâ”€â”€ .xlsx: CoreXLSX library (NEW - optional dependency)         â”‚   â”‚  â”‚
â”‚   â”‚  â”‚ â”œâ”€â”€ .pptx: ZIP + XMLParser (enhanced slide parsing)             â”‚   â”‚  â”‚
â”‚   â”‚  â”‚ â””â”€â”€ Graceful fallback if CoreXLSX unavailable                   â”‚   â”‚  â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚   â”‚                               â”‚ â–¼ (continue to try all)                â”‚  â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚   â”‚  â”‚ Strategy 3: NSAttributedString (macOS native)                   â”‚   â”‚  â”‚
â”‚   â”‚  â”‚ â”œâ”€â”€ .officeOpenXML type                                         â”‚   â”‚  â”‚
â”‚   â”‚  â”‚ â””â”€â”€ .docFormat type                                             â”‚   â”‚  â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚   â”‚                               â”‚ â–¼ (continue to try all)                â”‚  â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚   â”‚  â”‚ Strategy 4: CLI Tools (textutil)                                â”‚   â”‚  â”‚
â”‚   â”‚  â”‚ â””â”€â”€ /usr/bin/textutil -convert txt -stdout                      â”‚   â”‚  â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚   â”‚                               â”‚ â–¼ (always run)                         â”‚  â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚   â”‚  â”‚ Strategy 5: Filename + Metadata Fallback (always succeeds)      â”‚   â”‚  â”‚
â”‚   â”‚  â”‚ â”œâ”€â”€ Extract filename keywords                                   â”‚   â”‚  â”‚
â”‚   â”‚  â”‚ â”œâ”€â”€ File size, dates, author (if available)                     â”‚   â”‚  â”‚
â”‚   â”‚  â”‚ â””â”€â”€ Flag for manual review if text < threshold                  â”‚   â”‚  â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚   â”‚                                                                         â”‚  â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚   â”‚  â”‚ Result Aggregator                                               â”‚   â”‚  â”‚
â”‚   â”‚  â”‚ â”œâ”€â”€ Combine text from ALL successful strategies                 â”‚   â”‚  â”‚
â”‚   â”‚  â”‚ â”œâ”€â”€ Deduplicate overlapping content                             â”‚   â”‚  â”‚
â”‚   â”‚  â”‚ â”œâ”€â”€ Calculate extraction quality score                          â”‚   â”‚  â”‚
â”‚   â”‚  â”‚ â””â”€â”€ Set needsManualReview flag if quality < threshold           â”‚   â”‚  â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚   â”‚                                                                         â”‚  â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 New Components

| Component | Type | Purpose |
|-----------|------|---------|
| `OfficeDocumentExtractor` | Actor | Orchestrates multi-strategy extraction |
| `SpotlightMetadataExtractor` | Struct | Extracts kMDItemTextContent via CoreServices |
| `CoreXLSXExtractor` | Struct | Excel parsing using CoreXLSX (optional) |
| `EnhancedPPTXExtractor` | Struct | Improved PowerPoint XML parsing |
| `ExtractionResult` | Struct | Aggregated result with quality metrics |
| `ExtractionConfiguration` | Struct | Fast/Thorough mode settings |

### 3.3 Configuration Options

```swift
struct ExtractionConfiguration: Codable, Sendable {
    /// Extraction mode
    enum Mode: String, Codable {
        case fast       // Skip slow methods, don't trigger indexing
        case thorough   // Try everything, trigger mdimport if needed
    }
    
    var mode: Mode = .fast
    
    /// Minimum characters to consider extraction successful
    var minimumTextLength: Int = 50
    
    /// Use CoreXLSX if available (may add startup time)
    var useCoreXLSX: Bool = true
    
    /// Trigger Spotlight indexing for unindexed files (adds 1-3s)
    var triggerSpotlightIndexing: Bool = false
    
    /// Maximum time to wait for Spotlight indexing (seconds)
    var spotlightIndexingTimeout: TimeInterval = 5.0
}
```

---

## 4. Complete Pipeline Flow

### 4.1 End-to-End Document Processing

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         COMPLETE DOCUMENT PIPELINE                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                 â”‚
â”‚  PHASE 1: INGESTION                                                            â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                                           â”‚
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                              â”‚
â”‚  â”‚ User drops   â”‚                                                              â”‚
â”‚  â”‚ file(s) or   â”‚                                                              â”‚
â”‚  â”‚ folder       â”‚                                                              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜                                                              â”‚
â”‚         â”‚                                                                       â”‚
â”‚         â–¼                                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ FileRouter.route(url:)                                                   â”‚  â”‚
â”‚  â”‚ â”œâ”€â”€ Check file exists & readable                                         â”‚  â”‚
â”‚  â”‚ â”œâ”€â”€ Determine UTType from extension                                      â”‚  â”‚
â”‚  â”‚ â”œâ”€â”€ Map to InspectionStrategy                                            â”‚  â”‚
â”‚  â”‚ â”‚   â”œâ”€â”€ .document(.word)      â†’ .docx, .doc                              â”‚  â”‚
â”‚  â”‚ â”‚   â”œâ”€â”€ .document(.excel)     â†’ .xlsx, .xls, .csv                        â”‚  â”‚
â”‚  â”‚ â”‚   â”œâ”€â”€ .document(.powerpoint)â†’ .pptx, .ppt                              â”‚  â”‚
â”‚  â”‚ â”‚   â”œâ”€â”€ .document(.pdf)       â†’ .pdf                                     â”‚  â”‚
â”‚  â”‚ â”‚   â””â”€â”€ .document(.plainText) â†’ .txt, .md, etc.                          â”‚  â”‚
â”‚  â”‚ â””â”€â”€ Return InspectionStrategy                                            â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                                                                       â”‚
â”‚         â–¼                                                                       â”‚
â”‚  PHASE 2: INSPECTION (The Eye)                                                 â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                               â”‚
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ MediaInspector.inspect(url:)                                             â”‚  â”‚
â”‚  â”‚                                                                          â”‚  â”‚
â”‚  â”‚ Step 1: Compute file hash (checksum)                                     â”‚  â”‚
â”‚  â”‚         â””â”€â”€ QuickHash (metadata-based) or full SHA256                    â”‚  â”‚
â”‚  â”‚                                                                          â”‚  â”‚
â”‚  â”‚ Step 2: Route to type-specific inspection                                â”‚  â”‚
â”‚  â”‚         â””â”€â”€ inspectDocument(url:, type: .word/.excel/.powerpoint)        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                                                                       â”‚
â”‚         â–¼                                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ OfficeDocumentExtractor.extract(url:, type:) [NEW]                       â”‚  â”‚
â”‚  â”‚                                                                          â”‚  â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚ â”‚ 1. SpotlightMetadataExtractor.extract(url:)                        â”‚  â”‚  â”‚
â”‚  â”‚ â”‚    â”œâ”€â”€ MDItemCreate(NULL, url.path as CFString)                    â”‚  â”‚  â”‚
â”‚  â”‚ â”‚    â”œâ”€â”€ MDItemCopyAttribute(item, kMDItemTextContent)               â”‚  â”‚  â”‚
â”‚  â”‚ â”‚    â”œâ”€â”€ Also get: kMDItemTitle, kMDItemAuthors, kMDItemNumberOfPagesâ”‚  â”‚  â”‚
â”‚  â”‚ â”‚    â””â”€â”€ Returns: Optional<SpotlightMetadata>                        â”‚  â”‚  â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚ â”‚ 2. Format-specific native extraction                               â”‚  â”‚  â”‚
â”‚  â”‚ â”‚    â”œâ”€â”€ .docx: extractDocxFromZip() [existing, enhanced]            â”‚  â”‚  â”‚
â”‚  â”‚ â”‚    â”œâ”€â”€ .xlsx: CoreXLSXExtractor.extract() OR extractXLSXFromZip()  â”‚  â”‚  â”‚
â”‚  â”‚ â”‚    â”œâ”€â”€ .pptx: EnhancedPPTXExtractor.extract()                      â”‚  â”‚  â”‚
â”‚  â”‚ â”‚    â””â”€â”€ Legacy: NSAttributedString fallback                         â”‚  â”‚  â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚ â”‚ 3. CLI fallback (textutil for .doc/.docx)                          â”‚  â”‚  â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚ â”‚ 4. Aggregate results                                               â”‚  â”‚  â”‚
â”‚  â”‚ â”‚    â”œâ”€â”€ Combine text from all successful strategies                 â”‚  â”‚  â”‚
â”‚  â”‚ â”‚    â”œâ”€â”€ Deduplicate (longest unique substring selection)            â”‚  â”‚  â”‚
â”‚  â”‚ â”‚    â”œâ”€â”€ Calculate quality score: textLength / expectedLength        â”‚  â”‚  â”‚
â”‚  â”‚ â”‚    â””â”€â”€ Set needsManualReview if score < 0.2 OR text < 50 chars     â”‚  â”‚  â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚                                                                          â”‚  â”‚
â”‚  â”‚ Output: ExtractionResult {                                               â”‚  â”‚
â”‚  â”‚           text: String,                                                  â”‚  â”‚
â”‚  â”‚           metadata: SpotlightMetadata?,                                  â”‚  â”‚
â”‚  â”‚           qualityScore: Double,                                          â”‚  â”‚
â”‚  â”‚           methodsUsed: [ExtractionMethod],                               â”‚  â”‚
â”‚  â”‚           needsManualReview: Bool                                        â”‚  â”‚
â”‚  â”‚         }                                                                â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                                                                       â”‚
â”‚         â–¼                                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Create FileSignature                                                     â”‚  â”‚
â”‚  â”‚ â”œâ”€â”€ url, kind (.document), checksum                                      â”‚  â”‚
â”‚  â”‚ â”œâ”€â”€ textualCue: extractionResult.text.prefix(10_000)                     â”‚  â”‚
â”‚  â”‚ â”œâ”€â”€ pageCount, wordCount, language                                       â”‚  â”‚
â”‚  â”‚ â””â”€â”€ Custom: needsManualReview (via ProcessingItem.status)                â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                                                                       â”‚
â”‚         â–¼                                                                       â”‚
â”‚  PHASE 3: EMBEDDING GENERATION                                                 â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                             â”‚
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ EmbeddingGenerator.generateEmbedding(for: signature)                     â”‚  â”‚
â”‚  â”‚                                                                          â”‚  â”‚
â”‚  â”‚ Input: FileSignature.textualCue (extracted text)                         â”‚  â”‚
â”‚  â”‚                                                                          â”‚  â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚ â”‚ AppleNLEmbeddingService (Primary)                                  â”‚  â”‚  â”‚
â”‚  â”‚ â”‚ â”œâ”€â”€ NLEmbedding.sentenceEmbedding(for: text, language: .english)   â”‚  â”‚  â”‚
â”‚  â”‚ â”‚ â””â”€â”€ Returns: [Double] (512 dimensions)                             â”‚  â”‚  â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚ â”‚ NGramEmbedding (Fallback)                                          â”‚  â”‚  â”‚
â”‚  â”‚ â”‚ â”œâ”€â”€ Character n-grams (3-5 chars)                                  â”‚  â”‚  â”‚
â”‚  â”‚ â”‚ â””â”€â”€ Returns: [Double] (configurable dimensions)                    â”‚  â”‚  â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚                                                                          â”‚  â”‚
â”‚  â”‚ Output: [Double] - normalized embedding vector                           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                                                                       â”‚
â”‚         â–¼                                                                       â”‚
â”‚  PHASE 4: PATTERN MATCHING (Memory)                                            â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                           â”‚
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ MemoryStore.queryNearest(embedding:, threshold:)                         â”‚  â”‚
â”‚  â”‚                                                                          â”‚  â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚ â”‚ Step 1: Checksum exact match                                       â”‚  â”‚  â”‚
â”‚  â”‚ â”‚         â””â”€â”€ findByChecksum(signature.checksum)                     â”‚  â”‚  â”‚
â”‚  â”‚ â”‚         â””â”€â”€ If found: instant return with cached category          â”‚  â”‚  â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚ â”‚ Step 2: Vector similarity search                                   â”‚  â”‚  â”‚
â”‚  â”‚ â”‚         â”œâ”€â”€ Compute cosine similarity vs stored patterns           â”‚  â”‚  â”‚
â”‚  â”‚ â”‚         â””â”€â”€ If similarity >= 0.85: return matched category         â”‚  â”‚  â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚ â”‚ Step 3: No match â†’ proceed to LLM categorization                   â”‚  â”‚  â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                                                                       â”‚
â”‚         â–¼                                                                       â”‚
â”‚  PHASE 5: LLM CATEGORIZATION (Brain)                                           â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                           â”‚
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ UnifiedCategorizationService.categorize(signature:)                      â”‚  â”‚
â”‚  â”‚                                                                          â”‚  â”‚
â”‚  â”‚ Provider Cascade (try in order):                                         â”‚  â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚ â”‚ 1. Apple Intelligence (on-device, privacy-preserving)              â”‚  â”‚  â”‚
â”‚  â”‚ â”‚    â””â”€â”€ FoundationModels.Session.respond(to: prompt, generating:)   â”‚  â”‚  â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚ â”‚ 2. Ollama (local LLM server)                                       â”‚  â”‚  â”‚
â”‚  â”‚ â”‚    â””â”€â”€ POST /api/generate with model + prompt                      â”‚  â”‚  â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚ â”‚ 3. Local ML Fallback (keyword-based)                               â”‚  â”‚  â”‚
â”‚  â”‚ â”‚    â””â”€â”€ TaxonomyInferenceEngine.infer(from: keywords)               â”‚  â”‚  â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚                                                                          â”‚  â”‚
â”‚  â”‚ Prompt includes:                                                         â”‚  â”‚
â”‚  â”‚ â”œâ”€â”€ Existing category hierarchy (from KnowledgeGraph)                    â”‚  â”‚
â”‚  â”‚ â”œâ”€â”€ File metadata (name, size, type)                                     â”‚  â”‚
â”‚  â”‚ â”œâ”€â”€ Extracted text (truncated to ~3000 chars)                            â”‚  â”‚
â”‚  â”‚ â””â”€â”€ Scene tags / detected objects (for images/video)                     â”‚  â”‚
â”‚  â”‚                                                                          â”‚  â”‚
â”‚  â”‚ Output: CategorizationResult {                                           â”‚  â”‚
â”‚  â”‚           categoryPath: CategoryPath (e.g., Documents / Finance / Tax)   â”‚  â”‚
â”‚  â”‚           confidence: Double (0.0-1.0)                                   â”‚  â”‚
â”‚  â”‚           rationale: String                                              â”‚  â”‚
â”‚  â”‚           extractedKeywords: [String]                                    â”‚  â”‚
â”‚  â”‚           provider: LLMProviderIdentifier                                â”‚  â”‚
â”‚  â”‚         }                                                                â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                                                                       â”‚
â”‚         â–¼                                                                       â”‚
â”‚  PHASE 6: RESULT & FEEDBACK                                                    â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                               â”‚
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ Create ProcessingResult                                                  â”‚  â”‚
â”‚  â”‚ â”œâ”€â”€ signature: FileSignature                                             â”‚  â”‚
â”‚  â”‚ â”œâ”€â”€ brainResult: BrainResult (category, confidence, rationale)           â”‚  â”‚
â”‚  â”‚ â””â”€â”€ wasFromMemory: Bool                                                  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                                                                       â”‚
â”‚         â–¼                                                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ FeedbackManager.addToQueue()                                             â”‚  â”‚
â”‚  â”‚                                                                          â”‚  â”‚
â”‚  â”‚ Decision tree:                                                           â”‚  â”‚
â”‚  â”‚ â”œâ”€â”€ confidence >= 0.85 AND NOT needsManualReview                         â”‚  â”‚
â”‚  â”‚ â”‚   â””â”€â”€ Auto-accept â†’ proceed to organization                            â”‚  â”‚
â”‚  â”‚ â”œâ”€â”€ confidence < 0.85 OR needsManualReview                               â”‚  â”‚
â”‚  â”‚ â”‚   â””â”€â”€ Queue for human review                                           â”‚  â”‚
â”‚  â”‚ â””â”€â”€ Low-confidence extraction (text < 50 chars)                          â”‚  â”‚
â”‚  â”‚     â””â”€â”€ Flag as "needs manual review" with reason                        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                                                                       â”‚
â”‚         â–¼                                                                       â”‚
â”‚  PHASE 7: FILE ORGANIZATION                                                    â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                               â”‚
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ SafeFileOrganizer.organize()                                             â”‚  â”‚
â”‚  â”‚                                                                          â”‚  â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚ â”‚ Step 1: Resolve destination path                                   â”‚  â”‚  â”‚
â”‚  â”‚ â”‚         outputFolder / Category / Subcategory / ... / filename     â”‚  â”‚  â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚ â”‚ Step 2: Handle collisions                                          â”‚  â”‚  â”‚
â”‚  â”‚ â”‚         â””â”€â”€ Auto-rename: "file (1).docx", "file (2).docx"          â”‚  â”‚  â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚ â”‚ Step 3: Execute operation (based on config)                        â”‚  â”‚  â”‚
â”‚  â”‚ â”‚         â”œâ”€â”€ .copy   â†’ FileManager.copyItem()                       â”‚  â”‚  â”‚
â”‚  â”‚ â”‚         â”œâ”€â”€ .move   â†’ FileManager.moveItem()                       â”‚  â”‚  â”‚
â”‚  â”‚ â”‚         â””â”€â”€ .symlinkâ†’ FileManager.createSymbolicLink()             â”‚  â”‚  â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚
â”‚  â”‚ â”‚ Step 4: Log to MovementLog (for undo support)                      â”‚  â”‚  â”‚
â”‚  â”‚ â”‚         â”œâ”€â”€ source, destination, timestamp                         â”‚  â”‚  â”‚
â”‚  â”‚ â”‚         â”œâ”€â”€ category, confidence, provider                         â”‚  â”‚  â”‚
â”‚  â”‚ â”‚         â””â”€â”€ undoable: true                                         â”‚  â”‚  â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                                                                       â”‚
â”‚         â–¼                                                                       â”‚
â”‚  PHASE 8: LEARNING (Memory Update)                                             â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                             â”‚
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ MemoryStore.savePattern()                                                â”‚  â”‚
â”‚  â”‚                                                                          â”‚  â”‚
â”‚  â”‚ For auto-accepted results (confidence >= 0.85):                          â”‚  â”‚
â”‚  â”‚ â”œâ”€â”€ Store checksum â†’ category mapping                                    â”‚  â”‚
â”‚  â”‚ â”œâ”€â”€ Store embedding â†’ category mapping                                   â”‚  â”‚
â”‚  â”‚ â””â”€â”€ Update KnowledgeGraph with keywords                                  â”‚  â”‚
â”‚  â”‚                                                                          â”‚  â”‚
â”‚  â”‚ For human-corrected results:                                             â”‚  â”‚
â”‚  â”‚ â”œâ”€â”€ Store corrected category with confidence = 1.0                       â”‚  â”‚
â”‚  â”‚ â”œâ”€â”€ Update keyword weights in KnowledgeGraph                             â”‚  â”‚
â”‚  â”‚ â””â”€â”€ Strengthen/weaken category associations                              â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 5. Implementation Details

### 5.1 SpotlightMetadataExtractor

```swift
// Sources/SortAI/Core/Eye/SpotlightMetadataExtractor.swift

import Foundation
import CoreServices

/// Metadata extracted from Spotlight index
struct SpotlightMetadata: Sendable {
    let textContent: String?
    let title: String?
    let authors: [String]?
    let numberOfPages: Int?
    let creator: String?
    let contentCreationDate: Date?
    let contentModificationDate: Date?
}

/// Extracts text content from Spotlight's index (kMDItemTextContent)
struct SpotlightMetadataExtractor {
    
    /// Extract metadata from Spotlight index
    /// Returns nil if file is not indexed (does NOT throw)
    func extract(url: URL) -> SpotlightMetadata? {
        guard let item = MDItemCreate(nil, url.path as CFString) else {
            NSLog("ğŸ“ [Spotlight] File not indexed: \(url.lastPathComponent)")
            return nil
        }
        
        let textContent = MDItemCopyAttribute(item, kMDItemTextContent) as? String
        let title = MDItemCopyAttribute(item, kMDItemTitle) as? String
        let authors = MDItemCopyAttribute(item, kMDItemAuthors) as? [String]
        let pages = MDItemCopyAttribute(item, kMDItemNumberOfPages) as? Int
        let creator = MDItemCopyAttribute(item, kMDItemCreator) as? String
        let creationDate = MDItemCopyAttribute(item, kMDItemContentCreationDate) as? Date
        let modDate = MDItemCopyAttribute(item, kMDItemContentModificationDate) as? Date
        
        // Log what we found
        let textLength = textContent?.count ?? 0
        NSLog("ğŸ“ [Spotlight] Extracted \(textLength) chars from: \(url.lastPathComponent)")
        
        return SpotlightMetadata(
            textContent: textContent,
            title: title,
            authors: authors,
            numberOfPages: pages,
            creator: creator,
            contentCreationDate: creationDate,
            contentModificationDate: modDate
        )
    }
    
    /// Trigger Spotlight indexing for a file (blocking, with timeout)
    func triggerIndexing(url: URL, timeout: TimeInterval = 5.0) async -> Bool {
        let process = Process()
        process.executableURL = URL(fileURLWithPath: "/usr/bin/mdimport")
        process.arguments = [url.path]
        process.standardOutput = FileHandle.nullDevice
        process.standardError = FileHandle.nullDevice
        
        do {
            try process.run()
            
            // Wait with timeout
            let deadline = Date().addingTimeInterval(timeout)
            while process.isRunning && Date() < deadline {
                try await Task.sleep(nanoseconds: 100_000_000) // 0.1s
            }
            
            if process.isRunning {
                process.terminate()
                return false
            }
            
            return process.terminationStatus == 0
        } catch {
            return false
        }
    }
}
```

### 5.2 CoreXLSX Integration

```swift
// Sources/SortAI/Core/Eye/CoreXLSXExtractor.swift

import Foundation

/// Wrapper for CoreXLSX library with graceful fallback
/// Uses conditional compilation to handle missing dependency
struct CoreXLSXExtractor {
    
    /// Check if CoreXLSX is available at runtime
    static var isAvailable: Bool {
        #if canImport(CoreXLSX)
        return true
        #else
        return false
        #endif
    }
    
    /// Extract text from Excel file using CoreXLSX
    /// Falls back to ZIP extraction if library unavailable
    func extract(url: URL) -> ExtractionResult {
        #if canImport(CoreXLSX)
        return extractWithCoreXLSX(url: url)
        #else
        NSLog("ğŸ“Š [CoreXLSX] Library not available, using ZIP fallback")
        return ExtractionResult(
            text: nil,
            method: .zipXML,
            error: "CoreXLSX not available"
        )
        #endif
    }
    
    #if canImport(CoreXLSX)
    private func extractWithCoreXLSX(url: URL) -> ExtractionResult {
        do {
            let file = try XLSXFile(filepath: url.path)
            var allText: [String] = []
            
            // Get shared strings (text values)
            if let sharedStrings = try file.parseSharedStrings() {
                allText.append(contentsOf: sharedStrings.items.compactMap { $0.text })
            }
            
            // Parse each worksheet
            for wbk in try file.parseWorkbooks() {
                for (name, path) in try file.parseWorksheetPathsAndNames(workbook: wbk) {
                    allText.append("Sheet: \(name)")
                    
                    let worksheet = try file.parseWorksheet(at: path)
                    // Extract cell values
                    if let rows = worksheet.data?.rows {
                        for row in rows {
                            for cell in row.cells {
                                if let value = cell.stringValue(sharedStrings) {
                                    allText.append(value)
                                }
                            }
                        }
                    }
                }
            }
            
            let text = allText.joined(separator: " ")
            NSLog("ğŸ“Š [CoreXLSX] Extracted \(text.count) chars from: \(url.lastPathComponent)")
            
            return ExtractionResult(
                text: text,
                method: .coreXLSX,
                error: nil
            )
        } catch {
            NSLog("âš ï¸ [CoreXLSX] Extraction failed: \(error.localizedDescription)")
            return ExtractionResult(
                text: nil,
                method: .coreXLSX,
                error: error.localizedDescription
            )
        }
    }
    #endif
}
```

### 5.3 Enhanced PowerPoint Extractor

```swift
// Sources/SortAI/Core/Eye/EnhancedPPTXExtractor.swift

import Foundation

/// Enhanced PowerPoint extraction with slide order preservation
struct EnhancedPPTXExtractor {
    
    func extract(url: URL) -> (text: String, slideCount: Int)? {
        let fileManager = FileManager.default
        let tempDir = fileManager.temporaryDirectory.appendingPathComponent(UUID().uuidString)
        
        defer {
            try? fileManager.removeItem(at: tempDir)
        }
        
        // Unzip PPTX
        guard unzip(url: url, to: tempDir) else {
            return nil
        }
        
        var slides: [(number: Int, text: String)] = []
        
        // Parse slide files in order
        let slidesDir = tempDir.appendingPathComponent("ppt/slides")
        guard let slideFiles = try? fileManager.contentsOfDirectory(at: slidesDir, includingPropertiesForKeys: nil) else {
            return nil
        }
        
        for slideFile in slideFiles where slideFile.lastPathComponent.hasPrefix("slide") {
            // Extract slide number from filename (slide1.xml, slide2.xml, etc.)
            let filename = slideFile.deletingPathExtension().lastPathComponent
            guard let slideNum = Int(filename.replacingOccurrences(of: "slide", with: "")) else {
                continue
            }
            
            if let slideText = extractSlideText(from: slideFile) {
                slides.append((number: slideNum, text: slideText))
            }
        }
        
        // Sort by slide number
        slides.sort { $0.number < $1.number }
        
        // Combine with slide separators
        var fullText = ""
        for slide in slides {
            fullText += "--- Slide \(slide.number) ---\n"
            fullText += slide.text + "\n\n"
        }
        
        // Also extract notes if available
        let notesDir = tempDir.appendingPathComponent("ppt/notesSlides")
        if let notesFiles = try? fileManager.contentsOfDirectory(at: notesDir, includingPropertiesForKeys: nil) {
            for notesFile in notesFiles {
                if let notesText = extractSlideText(from: notesFile), !notesText.isEmpty {
                    fullText += "--- Speaker Notes ---\n"
                    fullText += notesText + "\n"
                }
            }
        }
        
        NSLog("ğŸ“½ï¸ [PPTX] Extracted \(fullText.count) chars from \(slides.count) slides")
        return (text: fullText.trimmingCharacters(in: .whitespacesAndNewlines), slideCount: slides.count)
    }
    
    private func extractSlideText(from url: URL) -> String? {
        guard let data = try? Data(contentsOf: url),
              let content = String(data: data, encoding: .utf8) else {
            return nil
        }
        
        // Extract text from <a:t> tags (PowerPoint text elements)
        let pattern = "<a:t>([^<]*)</a:t>"
        guard let regex = try? NSRegularExpression(pattern: pattern) else {
            return nil
        }
        
        let range = NSRange(content.startIndex..., in: content)
        let matches = regex.matches(in: content, range: range)
        
        var texts: [String] = []
        for match in matches {
            if let textRange = Range(match.range(at: 1), in: content) {
                let text = String(content[textRange]).trimmingCharacters(in: .whitespaces)
                if !text.isEmpty {
                    texts.append(text)
                }
            }
        }
        
        return texts.joined(separator: " ")
    }
    
    private func unzip(url: URL, to destination: URL) -> Bool {
        let process = Process()
        process.executableURL = URL(fileURLWithPath: "/usr/bin/unzip")
        process.arguments = ["-q", "-o", url.path, "-d", destination.path]
        process.standardOutput = FileHandle.nullDevice
        process.standardError = FileHandle.nullDevice
        
        do {
            try process.run()
            process.waitUntilExit()
            return process.terminationStatus == 0
        } catch {
            return false
        }
    }
}
```

### 5.4 OfficeDocumentExtractor (Orchestrator)

```swift
// Sources/SortAI/Core/Eye/OfficeDocumentExtractor.swift

import Foundation

/// Extraction method identifier
enum ExtractionMethod: String, Codable, Sendable {
    case spotlight
    case coreXLSX
    case zipXML
    case nsAttributedString
    case textutil
    case filenameFallback
}

/// Result from a single extraction attempt
struct ExtractionAttempt: Sendable {
    let method: ExtractionMethod
    let text: String?
    let metadata: SpotlightMetadata?
    let error: String?
    let durationMs: Int
    
    var succeeded: Bool { text != nil && !text!.isEmpty }
}

/// Aggregated extraction result
struct OfficeExtractionResult: Sendable {
    let aggregatedText: String
    let attempts: [ExtractionAttempt]
    let qualityScore: Double  // 0.0-1.0
    let needsManualReview: Bool
    let spotlightMetadata: SpotlightMetadata?
    
    var successfulMethods: [ExtractionMethod] {
        attempts.filter { $0.succeeded }.map { $0.method }
    }
}

/// Orchestrates multi-strategy Office document extraction
actor OfficeDocumentExtractor {
    
    private let config: ExtractionConfiguration
    private let spotlightExtractor = SpotlightMetadataExtractor()
    private let xlsxExtractor = CoreXLSXExtractor()
    private let pptxExtractor = EnhancedPPTXExtractor()
    
    init(configuration: ExtractionConfiguration = .default) {
        self.config = configuration
    }
    
    /// Extract text from an Office document using all available methods
    func extract(url: URL, type: InspectionStrategy.DocumentType) async -> OfficeExtractionResult {
        var attempts: [ExtractionAttempt] = []
        var spotlightMeta: SpotlightMetadata? = nil
        
        let filename = url.lastPathComponent
        NSLog("ğŸ“„ [OfficeExtractor] Starting extraction: \(filename)")
        
        // STRATEGY 1: Spotlight (FIRST - fastest if indexed)
        let spotlightStart = Date()
        if var meta = spotlightExtractor.extract(url: url) {
            spotlightMeta = meta
            attempts.append(ExtractionAttempt(
                method: .spotlight,
                text: meta.textContent,
                metadata: meta,
                error: nil,
                durationMs: Int(Date().timeIntervalSince(spotlightStart) * 1000)
            ))
        } else if config.triggerSpotlightIndexing && config.mode == .thorough {
            // Thorough mode: try indexing
            NSLog("ğŸ“ [Spotlight] Triggering indexing for: \(filename)")
            if await spotlightExtractor.triggerIndexing(url: url, timeout: config.spotlightIndexingTimeout) {
                if let meta = spotlightExtractor.extract(url: url) {
                    spotlightMeta = meta
                    attempts.append(ExtractionAttempt(
                        method: .spotlight,
                        text: meta.textContent,
                        metadata: meta,
                        error: nil,
                        durationMs: Int(Date().timeIntervalSince(spotlightStart) * 1000)
                    ))
                }
            }
        }
        
        // STRATEGY 2: Format-specific native extraction
        let nativeStart = Date()
        let nativeResult = await extractNative(url: url, type: type)
        attempts.append(ExtractionAttempt(
            method: nativeResult.method,
            text: nativeResult.text,
            metadata: nil,
            error: nativeResult.error,
            durationMs: Int(Date().timeIntervalSince(nativeStart) * 1000)
        ))
        
        // STRATEGY 3: NSAttributedString
        let nsStart = Date()
        let nsResult = extractViaNSAttributedString(url: url)
        attempts.append(ExtractionAttempt(
            method: .nsAttributedString,
            text: nsResult.text,
            metadata: nil,
            error: nsResult.error,
            durationMs: Int(Date().timeIntervalSince(nsStart) * 1000)
        ))
        
        // STRATEGY 4: textutil (Word only)
        if type == .word {
            let textutilStart = Date()
            let textutilResult = extractViaTextutil(url: url)
            attempts.append(ExtractionAttempt(
                method: .textutil,
                text: textutilResult,
                metadata: nil,
                error: textutilResult == nil ? "textutil failed" : nil,
                durationMs: Int(Date().timeIntervalSince(textutilStart) * 1000)
            ))
        }
        
        // AGGREGATE RESULTS
        let aggregatedText = aggregateText(from: attempts)
        let qualityScore = calculateQualityScore(text: aggregatedText, url: url)
        let needsReview = qualityScore < 0.2 || aggregatedText.count < config.minimumTextLength
        
        NSLog("ğŸ“„ [OfficeExtractor] Completed: \(filename) - \(aggregatedText.count) chars, quality: \(String(format: "%.2f", qualityScore)), methods: \(attempts.filter { $0.succeeded }.map { $0.method.rawValue }.joined(separator: ", "))")
        
        return OfficeExtractionResult(
            aggregatedText: aggregatedText,
            attempts: attempts,
            qualityScore: qualityScore,
            needsManualReview: needsReview,
            spotlightMetadata: spotlightMeta
        )
    }
    
    // MARK: - Private Helpers
    
    private func extractNative(url: URL, type: InspectionStrategy.DocumentType) async -> (text: String?, method: ExtractionMethod, error: String?) {
        switch type {
        case .word:
            return extractDocxFromZip(url: url)
        case .excel:
            if config.useCoreXLSX && CoreXLSXExtractor.isAvailable {
                let result = xlsxExtractor.extract(url: url)
                if let text = result.text {
                    return (text, .coreXLSX, nil)
                }
            }
            // Fallback to ZIP extraction
            return extractXLSXFromZip(url: url)
        case .powerpoint:
            if let result = pptxExtractor.extract(url: url) {
                return (result.text, .zipXML, nil)
            }
            return (nil, .zipXML, "PPTX extraction failed")
        default:
            return (nil, .zipXML, "Unsupported type")
        }
    }
    
    private func aggregateText(from attempts: [ExtractionAttempt]) -> String {
        // Get all successful extractions
        let texts = attempts.compactMap { $0.text }.filter { !$0.isEmpty }
        
        if texts.isEmpty {
            return ""
        }
        
        // Use the longest text as base (usually most complete)
        // Then append unique content from shorter texts
        let sorted = texts.sorted { $0.count > $1.count }
        var result = sorted[0]
        
        for text in sorted.dropFirst() {
            // Simple deduplication: add text if it's not a substring
            if !result.localizedCaseInsensitiveContains(text.prefix(100)) {
                result += "\n\n" + text
            }
        }
        
        return result
    }
    
    private func calculateQualityScore(text: String, url: URL) -> Double {
        let textLength = text.count
        
        // Estimate expected length based on file size
        let fileSize = (try? FileManager.default.attributesOfItem(atPath: url.path)[.size] as? Int64) ?? 0
        
        // Rough estimate: 1KB of Office file â‰ˆ 500 chars of text
        let expectedLength = Double(fileSize) / 2.0
        
        guard expectedLength > 0 else { return 0.0 }
        
        let ratio = Double(textLength) / expectedLength
        return min(ratio, 1.0)
    }
    
    // ... existing ZIP extraction methods moved here ...
}
```

---

## 6. Dependencies & Configuration

### 6.1 Package.swift Changes

```swift
// Package.swift additions

dependencies: [
    .package(url: "https://github.com/groue/GRDB.swift.git", from: "6.29.0"),
    // NEW: CoreXLSX for Excel parsing (optional, graceful degradation)
    .package(url: "https://github.com/CoreOffice/CoreXLSX.git", from: "0.14.0"),
    // NEW: ZIPFoundation for better ZIP handling (optional)
    .package(url: "https://github.com/weichsel/ZIPFoundation.git", from: "0.9.0"),
],
targets: [
    .executableTarget(
        name: "SortAI",
        dependencies: [
            .product(name: "GRDB", package: "GRDB.swift"),
            // Optional dependencies - graceful fallback if unavailable
            .product(name: "CoreXLSX", package: "CoreXLSX", condition: .when(platforms: [.macOS])),
            .product(name: "ZIPFoundation", package: "ZIPFoundation", condition: .when(platforms: [.macOS])),
        ],
        // ...
    ),
]
```

### 6.2 Configuration Additions

```swift
// AppConfiguration.swift additions

struct ExtractionConfiguration: Codable, Sendable, Equatable {
    enum Mode: String, Codable, Sendable {
        case fast
        case thorough
    }
    
    var mode: Mode
    var minimumTextLength: Int
    var useCoreXLSX: Bool
    var triggerSpotlightIndexing: Bool
    var spotlightIndexingTimeout: TimeInterval
    
    static let `default` = ExtractionConfiguration(
        mode: .fast,
        minimumTextLength: 50,
        useCoreXLSX: true,
        triggerSpotlightIndexing: false,
        spotlightIndexingTimeout: 5.0
    )
    
    static let thorough = ExtractionConfiguration(
        mode: .thorough,
        minimumTextLength: 50,
        useCoreXLSX: true,
        triggerSpotlightIndexing: true,
        spotlightIndexingTimeout: 10.0
    )
}

// Add to AppConfiguration
struct AppConfiguration: Codable, Sendable {
    // ... existing fields ...
    
    /// Office document extraction settings
    var extraction: ExtractionConfiguration
}
```

### 6.3 UserDefaults Keys

```swift
// Add to SortAIDefaultsKey enum
static let extractionMode = "extractionMode"
static let minimumTextLength = "minimumTextLength"
static let useCoreXLSX = "useCoreXLSX"
static let triggerSpotlightIndexing = "triggerSpotlightIndexing"
static let spotlightIndexingTimeout = "spotlightIndexingTimeout"
```

---

## 7. Testing Strategy

### 7.1 Unit Tests

```swift
// Tests/SortAITests/OfficeExtractionTests.swift

final class OfficeExtractionTests: XCTestCase {
    
    // MARK: - Spotlight Metadata Tests
    
    func testSpotlightExtraction_IndexedFile() async throws {
        // Given: A file in a Spotlight-indexed location
        let testFile = createTestDocx(in: FileManager.default.temporaryDirectory)
        
        // When: Extracting via Spotlight
        let extractor = SpotlightMetadataExtractor()
        // Wait for indexing (or use pre-indexed fixture)
        try await Task.sleep(nanoseconds: 2_000_000_000)
        
        let result = extractor.extract(url: testFile)
        
        // Then: Should return metadata (if indexed)
        // Note: May be nil in sandboxed test environments
        XCTAssertNotNil(result?.textContent ?? result?.title ?? "fallback")
    }
    
    func testSpotlightExtraction_UnindexedFile() {
        // Given: A file not indexed by Spotlight
        let tempFile = FileManager.default.temporaryDirectory
            .appendingPathComponent(UUID().uuidString)
            .appendingPathExtension("docx")
        
        // When: Extracting immediately
        let extractor = SpotlightMetadataExtractor()
        let result = extractor.extract(url: tempFile)
        
        // Then: Should return nil gracefully
        XCTAssertNil(result)
    }
    
    // MARK: - CoreXLSX Tests
    
    func testCoreXLSXExtraction_ValidFile() async {
        // Given: A valid XLSX file
        let testFile = Bundle.module.url(forResource: "test_spreadsheet", withExtension: "xlsx")!
        
        // When: Extracting with CoreXLSX
        let extractor = CoreXLSXExtractor()
        let result = extractor.extract(url: testFile)
        
        // Then: Should extract cell contents
        XCTAssertNotNil(result.text)
        XCTAssertTrue(result.text!.count > 0)
    }
    
    func testCoreXLSXExtraction_CorruptedFile() async {
        // Given: An invalid/corrupted XLSX
        let testFile = createCorruptedXLSX()
        
        // When: Extracting
        let extractor = CoreXLSXExtractor()
        let result = extractor.extract(url: testFile)
        
        // Then: Should return nil gracefully (not throw)
        XCTAssertNil(result.text)
        XCTAssertNotNil(result.error)
    }
    
    // MARK: - Aggregation Tests
    
    func testAggregation_MultipleSources() async {
        // Given: Multiple extraction results
        let extractor = OfficeDocumentExtractor()
        let testFile = createTestDocx(withContent: "Hello World")
        
        // When: Running full extraction
        let result = await extractor.extract(url: testFile, type: .word)
        
        // Then: Should aggregate from multiple sources
        XCTAssertTrue(result.successfulMethods.count >= 1)
        XCTAssertTrue(result.aggregatedText.contains("Hello"))
    }
    
    func testAggregation_DeduplicationWorks() async {
        // Test that duplicate content is not repeated
    }
    
    // MARK: - Manual Review Flag Tests
    
    func testManualReviewFlag_InsufficientText() async {
        // Given: A file with minimal extractable text
        let testFile = createMinimalDocx()
        
        // When: Extracting
        let extractor = OfficeDocumentExtractor(configuration: .init(minimumTextLength: 100))
        let result = await extractor.extract(url: testFile, type: .word)
        
        // Then: Should flag for manual review
        XCTAssertTrue(result.needsManualReview)
    }
    
    // MARK: - Format-Specific Tests
    
    func testWordExtraction_Docx() async { }
    func testWordExtraction_Doc() async { }
    func testExcelExtraction_Xlsx() async { }
    func testExcelExtraction_Xls() async { }
    func testPowerPointExtraction_Pptx() async { }
    func testPowerPointExtraction_Ppt() async { }
}
```

### 7.2 Integration Tests

```swift
// Tests/SortAITests/OfficeExtractionIntegrationTests.swift

final class OfficeExtractionIntegrationTests: XCTestCase {
    
    func testFullPipeline_DocxToCategorization() async throws {
        // Test complete flow: DOCX â†’ FileSignature â†’ Embedding â†’ Category
    }
    
    func testFullPipeline_XlsxToCategorization() async throws {
        // Test complete flow: XLSX â†’ FileSignature â†’ Embedding â†’ Category
    }
    
    func testGracefulDegradation_AllMethodsFail() async throws {
        // Test that pipeline continues even when extraction yields minimal text
    }
    
    func testManualReviewFlow_LowConfidenceExtraction() async throws {
        // Test that files are properly flagged for review
    }
}
```

### 7.3 Test Fixtures

Create test files in `Tests/Fixtures/Office/`:

```
Tests/Fixtures/Office/
â”œâ”€â”€ valid/
â”‚   â”œâ”€â”€ simple.docx          # Basic Word doc with text
â”‚   â”œâ”€â”€ complex.docx         # Tables, images, formatting
â”‚   â”œâ”€â”€ spreadsheet.xlsx     # Multi-sheet Excel
â”‚   â”œâ”€â”€ presentation.pptx    # Multi-slide PowerPoint
â”‚   â”œâ”€â”€ legacy.doc           # Old Word format
â”‚   â””â”€â”€ legacy.xls           # Old Excel format
â”œâ”€â”€ edge_cases/
â”‚   â”œâ”€â”€ empty.docx           # Empty document
â”‚   â”œâ”€â”€ image_only.docx      # No text, only images
â”‚   â”œâ”€â”€ password.xlsx        # Password-protected
â”‚   â””â”€â”€ corrupted.pptx       # Invalid file structure
â””â”€â”€ large/
    â”œâ”€â”€ large_doc.docx       # 100+ pages
    â””â”€â”€ large_spreadsheet.xlsx # 10,000+ rows
```

---

## 8. Migration & Rollout Plan

### 8.1 Phase 1: Infrastructure (Week 1)

| Task | Description | Dependencies |
|------|-------------|--------------|
| 1.1 | Add CoreXLSX & ZIPFoundation to Package.swift | None |
| 1.2 | Create SpotlightMetadataExtractor | CoreServices import |
| 1.3 | Create ExtractionConfiguration struct | None |
| 1.4 | Add configuration to AppConfiguration | 1.3 |
| 1.5 | Add UserDefaults keys | 1.4 |

### 8.2 Phase 2: Extractors (Week 2)

| Task | Description | Dependencies |
|------|-------------|--------------|
| 2.1 | Create CoreXLSXExtractor with fallback | 1.1 |
| 2.2 | Create EnhancedPPTXExtractor | None |
| 2.3 | Create OfficeDocumentExtractor | 1.2, 2.1, 2.2 |
| 2.4 | Write unit tests for each extractor | 2.1, 2.2, 2.3 |

### 8.3 Phase 3: Integration (Week 3)

| Task | Description | Dependencies |
|------|-------------|--------------|
| 3.1 | Integrate OfficeDocumentExtractor into MediaInspector | 2.3 |
| 3.2 | Add needsManualReview flag to ProcessingItem | None |
| 3.3 | Update FeedbackManager for review flag | 3.2 |
| 3.4 | Update UI to show extraction quality indicator | 3.1 |
| 3.5 | Write integration tests | 3.1, 3.3 |

### 8.4 Phase 4: Settings & Polish (Week 4)

| Task | Description | Dependencies |
|------|-------------|--------------|
| 4.1 | Add extraction settings to SettingsView | 1.4 |
| 4.2 | Add "Extraction Quality" column to file list | 3.4 |
| 4.3 | Performance testing and optimization | 3.5 |
| 4.4 | Documentation update | All |

### 8.5 Rollout Strategy

1. **Feature Flag**: Add `enableEnhancedOfficeExtraction` flag (default: true)
2. **Gradual Rollout**: 
   - Week 4: Internal testing with flag enabled
   - Week 5: Release with flag enabled, old code path available
   - Week 6: Remove feature flag, old code deprecated

---

## 9. Performance Benchmarks

### 9.1 Baseline Metrics (Current)

| Format | Avg Time | Success Rate | Text Quality |
|--------|----------|--------------|--------------|
| .docx | 0.8s | 85% | Medium |
| .doc | 1.2s | 60% | Low |
| .xlsx | 1.5s | 70% | Low |
| .xls | 2.0s | 40% | Very Low |
| .pptx | 2.0s | 65% | Medium |
| .ppt | 2.5s | 30% | Very Low |

### 9.2 Target Metrics (Post-Implementation)

| Format | Target Time | Target Success | Target Quality |
|--------|-------------|----------------|----------------|
| .docx | < 0.5s | 98% | High |
| .doc | < 1.0s | 80% | Medium |
| .xlsx | < 0.8s | 95% | High |
| .xls | < 1.5s | 70% | Medium |
| .pptx | < 1.0s | 95% | High |
| .ppt | < 2.0s | 60% | Medium |

### 9.3 Benchmark Test Suite

```swift
// Tests/SortAITests/OfficeExtractionBenchmarks.swift

final class OfficeExtractionBenchmarks: XCTestCase {
    
    func testBenchmark_DocxExtraction() throws {
        let testFile = Bundle.module.url(forResource: "benchmark_doc", withExtension: "docx")!
        
        measure {
            let extractor = OfficeDocumentExtractor()
            _ = Task {
                await extractor.extract(url: testFile, type: .word)
            }
        }
    }
    
    func testBenchmark_XlsxExtraction() throws {
        // Similar for Excel
    }
    
    func testBenchmark_SpotlightVsZip() throws {
        // Compare Spotlight vs ZIP extraction times
    }
}
```

### 9.4 Performance Monitoring

Add metrics collection:

```swift
struct ExtractionMetrics: Codable {
    let fileType: String
    let fileSize: Int64
    let extractionTimeMs: Int
    let methodUsed: ExtractionMethod
    let textLength: Int
    let qualityScore: Double
    let timestamp: Date
}

// Log to database for analysis
try database.extractionMetrics.create(metrics)
```

---

## 10. Risk Mitigation

### 10.1 Identified Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| CoreXLSX dependency issues | Medium | Medium | Graceful fallback to ZIP extraction |
| Spotlight not indexed | High | Low | Silent skip, use other methods |
| Legacy format failures | High | Medium | Accept graceful degradation, flag for review |
| Memory pressure on large files | Medium | High | Stream processing, size limits |
| Permission issues (sandboxing) | Medium | Medium | Request appropriate entitlements |

### 10.2 Fallback Chain

```
1. Spotlight Metadata      â†’ Skip if not indexed
2. CoreXLSX (Excel)        â†’ Fall back to ZIP extraction
3. ZIP + XML Parsing       â†’ Fall back to NSAttributedString
4. NSAttributedString      â†’ Fall back to textutil
5. textutil CLI            â†’ Fall back to filename
6. Filename + Metadata     â†’ Always succeeds, flag for review
```

### 10.3 Error Handling Principles

1. **Never throw** from extraction methods - always return partial results
2. **Log all failures** for debugging but don't surface to users
3. **Aggregate successes** - partial text is better than no text
4. **Flag uncertainties** - let humans review questionable results

### 10.4 Monitoring & Alerting

Track these metrics:

- Extraction success rate by format
- Average extraction time by format
- Manual review flag rate
- Memory usage during extraction

---

## Appendix A: File Locations

```
Sources/SortAI/Core/Eye/
â”œâ”€â”€ MediaInspector.swift           # Main inspector (modify)
â”œâ”€â”€ OfficeDocumentExtractor.swift  # NEW: Orchestrator
â”œâ”€â”€ SpotlightMetadataExtractor.swift # NEW: Spotlight access
â”œâ”€â”€ CoreXLSXExtractor.swift        # NEW: Excel parsing
â””â”€â”€ EnhancedPPTXExtractor.swift    # NEW: PowerPoint parsing

Sources/SortAI/Core/Configuration/
â””â”€â”€ AppConfiguration.swift         # Add ExtractionConfiguration

Tests/SortAITests/
â”œâ”€â”€ OfficeExtractionTests.swift    # NEW: Unit tests
â”œâ”€â”€ OfficeExtractionIntegrationTests.swift # NEW: Integration tests
â””â”€â”€ OfficeExtractionBenchmarks.swift # NEW: Performance tests

Tests/Fixtures/Office/             # NEW: Test files
```

---

## Appendix B: API Reference

### SpotlightMetadataExtractor

```swift
struct SpotlightMetadataExtractor {
    func extract(url: URL) -> SpotlightMetadata?
    func triggerIndexing(url: URL, timeout: TimeInterval) async -> Bool
}
```

### OfficeDocumentExtractor

```swift
actor OfficeDocumentExtractor {
    init(configuration: ExtractionConfiguration)
    func extract(url: URL, type: InspectionStrategy.DocumentType) async -> OfficeExtractionResult
}
```

### ExtractionConfiguration

```swift
struct ExtractionConfiguration {
    var mode: Mode { .fast | .thorough }
    var minimumTextLength: Int
    var useCoreXLSX: Bool
    var triggerSpotlightIndexing: Bool
    var spotlightIndexingTimeout: TimeInterval
}
```

---

*Document Version: 1.0*
*Last Updated: January 2026*
*Author: SortAI Development Team*

